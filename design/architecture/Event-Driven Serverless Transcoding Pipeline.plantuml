@startuml Event-Driven Serverless Transcoding Pipeline with RWOS
!theme plain
'--- Visual Styling ---
skinparam boxPadding 10
skinparam participantPadding 10
autonumber "<b>[0]"

'--- Actors and Components ---
actor Client as "User Client"

box "Cloudflare Ecosystem" #e3f2fd
    participant Worker as "Worker API\n(Control Plane)"
    database R2 as "R2 Storage"
end box

box "Orchestration" #e8f5e9
    database Redis as "Upstash Redis"
end box

box "Compute Infrastructure" #fff3e0
    participant Fly as "Fly.io Machine\n(Pooled Worker)"
end box

box "Distribution" #f3e5f5
    participant CDN as "Bunny CDN"
end box

'--- 1. Authorization Phase ---
== 1. Authorization Phase ==
Client -> Worker: Request Upload Permission
activate Worker
Worker -> R2: Generate Presigned PUT URL
R2 --> Worker: Return Signed URL
Worker --> Client: Forward Presigned URL
deactivate Worker

'--- 2. Ingestion Phase ---
== 2. Ingestion Phase ==
Client -> R2: Direct Upload (Raw Video)
R2 -[#blue]> Worker: Event Notification (Object Created)

'--- 3. Job Orchestration Phase (RWOS) ---
== 3. Job Orchestration Phase ==
activate Worker
Worker -> Redis: ZADD jobs:pending (enqueue job)
Worker -> Redis: SPOP machines:stopped (check stopped machines)
alt Stopped Machine Available
    Worker -> Fly: POST /machines/{id}/start (start stopped machine)
    activate Fly
    Fly --> Worker: Machine started
    Worker -> Redis: HSET machines:pool {state: "running"}
    Worker -> Redis: SREM machines:stopped
else No Stopped Machines
    Worker -> Redis: HGETALL machines:pool (check pool size)
    alt Pool Size < MAX_MACHINES (10)
        Worker -> Fly: Create Machine via Machines API
        activate Fly
        Fly --> Worker: machine_id
        Worker -> Redis: HSET machines:pool {state: "running"}
    else Pool Full
        Worker --> Worker: Job stays queued for existing workers
    end
end
Worker --> Client: Return job_id + status
deactivate Worker

'--- 4. Processing Phase (Indefinite Polling) ---
== 4. Processing Phase ==
Fly -> Redis: Initialize in pool\n(HSET machines:pool {state: "running"})
loop Indefinitely (until stopped externally)
    Fly -> Redis: ZPOPMIN jobs:pending (atomic pop)
    alt Job Available
        Fly -> Redis: HSET machines:pool {state: "running", lastActiveAt}
        Fly -> Redis: HSET jobs:status (running)
        Fly -> R2: Download Raw Video
        Fly -> Fly: FFmpeg Transcode\n(480p, 720p, 1080p)
        Fly -> R2: Upload Processed Qualities
        Fly -> Redis: HSET jobs:status (completed)
        Fly -> Worker: Webhook: Job Complete
    else No Jobs Available
        Fly -> Redis: HSET machines:pool {state: "idle", lastActiveAt}
        Fly -> Fly: Sleep POLL_INTERVAL (5s)
    end
end
deactivate Fly

'--- 5. Discoverability Phase ---
== 5. Discoverability Phase ==
note over Worker, Client: Client becomes aware of the new URLs
activate Worker
Worker -> Worker: Update Video Status in DB
Worker -->> Client: Push Notification / WebSocket (Video Ready)
deactivate Worker

'--- 6. Distribution Phase ---
== 6. Distribution Phase ==
Client -> CDN: Pull Video via New URL
activate CDN
alt Cache Miss
    CDN -> R2: Origin Fetch (if not cached)
    R2 --> CDN: Video Data
end
CDN --> Client: Stream Video
deactivate CDN

'--- 7. Idle Machine Management (Cron) ---
== 7. Idle Machine Management (Cron) ==
Worker -> Redis: HGETALL machines:pool
loop For each machine
    alt state == "idle" AND\nlastActiveAt < (now - 5 minutes)
        Worker -> Fly: POST /machines/{id}/stop
        Worker -> Redis: HSET machines:pool {state: "stopped"}
        Worker -> Redis: SADD machines:stopped {machine_id}
    end
end

@enduml
